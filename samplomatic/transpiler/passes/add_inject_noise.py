# This code is a Qiskit project.
#
# (C) Copyright IBM 2025, 2026.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""AddInjectNoise"""

import itertools
from collections.abc import Callable
from typing import Literal

from qiskit.dagcircuit import DAGCircuit
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.exceptions import TranspilerError

from ...aliases import CircuitInstruction, DAGOpNode
from ...annotations import InjectNoise, Twirl
from ...utils import BoxKey, get_annotation, undress_box, validate_literals


class AddInjectNoise(TransformationPass):
    """Inserts :class:`~.InjectNoise` annotations to all the unique boxes with twirling annotation.

    This pass finds boxes matching the conditions implied by ``targets``, adds inject noise
    to their annotations, and replaces them with new boxes with the updated annotations.

    Args:
        strategy: The noise injection strategy.
        site: Whether to inject the noise before or after the associated hard content.
        overwrite: Whether to overwrite the ``ref`` of inject noise annotations that are already
            present in the circuit.
        prefix_ref: A prefix to all the ``ref`` generated by this class.
        prefix_modifier_ref: A prefix to all the ``modifier_refs`` generated by this class.
        targets: The class of annotated boxes to target. The supported values are:

                * ``'none'`` to avoid annotating boxes of any kind.
                * ``'gates'`` to target only the twirl-annotated boxes that contain entanglers.
                * ``'measures'`` to target only the twirl-annotated boxes that own classical
                    registers.
                * ``'all'`` to target all the twirl-annotated boxes that contain entanglers
                    and/or own classical registers.

    .. note::
        Every :meth:`~.InjectNoise.ref` is generated by appending the (truncated) hash of a box as
        specified by its :class:`~.BoxKey` to ``prefix_ref``. This means this pass assigns boxes
        with the same :class:`~.BoxKey` the same ``ref`` from circuit to circuit. When using the
        ``'uniform_modification'`` strategy, the ``modifier_ref`` will be set to ``ref``,
        allowing similar boxes to be modified uniformly. On the other hand, the
        ``'individual_modification'` strategy appends the value of a counter to ``modifier_ref``
        that is incremented following DAG traversal order.
    """

    _BOX_KEYS: dict[tuple[BoxKey, str], str] = {}
    _REFS: set[str] = set()

    @validate_literals("strategy", "site", "targets")
    def __init__(
        self,
        strategy: Literal[
            "no_modification", "uniform_modification", "individual_modification"
        ] = "no_modification",
        site: Literal["before", "after"] = "before",
        overwrite: bool = False,
        prefix_ref: str = "r",
        prefix_modifier_ref: str = "m",
        targets: Literal["none", "gates", "measures", "all"] = "none",
    ):
        super().__init__()
        self.strategy = strategy
        self.site = site
        self.overwrite = overwrite
        self.prefix_ref = prefix_ref
        self.prefix_modifier_ref = prefix_modifier_ref
        self.targets = targets

    def _get_ref(self, box_key: BoxKey) -> str:
        pair = (box_key, self.site)
        if pair in self._BOX_KEYS:
            return self._BOX_KEYS[pair]

        full_box_hash = hex(hash(pair)).split("x", maxsplit=1)[-1]
        for key_length in range(3, 16):
            if (box_hash := f"{self.prefix_ref}{full_box_hash[:key_length]}") not in self._REFS:
                self._BOX_KEYS[pair] = box_hash
                self._REFS.add(box_hash)
                return box_hash

        raise RuntimeError(
            "Could not resolve box hash collision: specify a manual reference counter."
        )

    def _skip_undressed_box(self) -> Callable[[DAGOpNode], bool]:
        if self.targets == "none":
            return True
        if self.targets == "all":
            # Skip boxes that do not contain entanglers or measurements
            return (
                lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
                and not undressed_box.body.clbits
            )
        if self.targets == "gates":
            return lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
        if self.targets == "measures":
            return lambda undressed_box: not undressed_box.body.clbits

        raise TranspilerError(
            f"Targets '{self.targets}' is invalid, choose one of 'none', 'all', 'gates',"
            " and 'measures'."
        )

    def run(self, dag: DAGCircuit) -> DAGCircuit:
        if self.targets == "none":
            return dag

        modifier_counter = itertools.count()
        run_references: dict[tuple[BoxKey, str], str] = {}

        skip_undressed_box: Callable[[DAGOpNode], bool] = self._skip_undressed_box()

        for node in dag.op_nodes():
            if node.op.name == "box" and (twirl := get_annotation(node.op, Twirl)):
                undressed_box = undress_box(node.op)
                undressed_box.annotations = [twirl]

                if skip_undressed_box(undressed_box):
                    continue

                instr_qubits = undressed_box.body.qubits
                instr_clbits = undressed_box.body.clbits
                instr = CircuitInstruction(undressed_box, instr_qubits, instr_clbits)
                box_key = BoxKey(instr)

                if inject_noise_annotation := get_annotation(node.op, InjectNoise):
                    current_site = inject_noise_annotation.site
                    if (box_key, current_site) not in self._BOX_KEYS:
                        self._BOX_KEYS[box_key, current_site] = inject_noise_annotation.ref
                        self._REFS.add(inject_noise_annotation.ref)
                    if (box_key, current_site) not in run_references:
                        run_references[box_key, current_site] = inject_noise_annotation.ref
                    else:
                        # The box already has a noise injection annotation, and another box with the
                        # same hash has previously been found.
                        if self.overwrite is True:
                            ref = run_references[box_key, current_site]
                            annotation_idx = node.op.annotations.index(inject_noise_annotation)
                            node.op.annotations[annotation_idx] = InjectNoise(
                                ref, inject_noise_annotation.modifier_ref, current_site
                            )
                            # substitute back into the dag to guarantee that the
                            # change makes it back to the rust data model.
                            dag.substitute_node(node, node.op)
                else:
                    # The box does not have a noise injection annotation.
                    if (box_key, self.site) in run_references:
                        ref = run_references[box_key, self.site]
                    elif (box_key, self.site) in self._BOX_KEYS:
                        ref = self._BOX_KEYS[box_key, self.site]
                    else:
                        ref = self._get_ref(box_key)

                    if self.overwrite is True and (box_key, self.site) not in run_references:
                        run_references[box_key, self.site] = ref

                    if self.strategy == "no_modification":
                        modifier_ref = ""
                    elif self.strategy == "uniform_modification":
                        modifier_ref = ref
                    else:
                        # individual modification
                        modifier_ref = f"{self.prefix_modifier_ref}{next(modifier_counter)}"

                    node.op.annotations += [InjectNoise(ref, modifier_ref, self.site)]
                    # substitute back into the dag to guarantee that the
                    # change makes it back to the rust data model.
                    dag.substitute_node(node, node.op)
        return dag
