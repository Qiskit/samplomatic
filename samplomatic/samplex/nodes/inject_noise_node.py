# This code is a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""InjectNoiseNode"""

import numpy as np
from qiskit.quantum_info import PauliLindbladMap

from ...aliases import NumSubsystems, RegisterName, StrRef
from ...annotations import VirtualType
from ...exceptions import SamplexRuntimeError
from ...virtual_registers import PauliRegister, Z2Register
from .sampling_node import SamplingNode


class InjectNoiseNode(SamplingNode):
    """A node that produces samples for injecting noise.

    The node uses a :class:`qiskit.quantum_info.PauliLindbladMap` as the distribution
    to draw samples from. This map can be modified at sample time with the following keyword
    arguments, applied in order:

    * ``noise_scales``, a dictionary from :class:`~.StrRef` to floats. If ``modifier_ref``
      is in the dictionary, the distribution is replaced with the one generated by
      by :meth:`qiskit.quantum_info.PauliLindbladMap.scale_rates`.
    * ``local_scales``, a dictionary from :class:`~.StrRef` to lists of floats. The list should be
      the same length as the map used. If ``modifier_ref`` is in the dictionary, the rates of
      :class:`qiskit.quantum_info.PauliLindbladMap` are scaled individually.

    Args:
        register_name: The name of the register to store the samples.
        sign_register_name: The name of the register to store the signs.
        noise_ref: Unique identifier of the noise map to draw samples from.
        num_subsystems: The number of subsystems this node generates gates for.
        modifier_ref: Unique identifier for modifiers applied to the noise map before sampling.
    """

    def __init__(
        self,
        register_name: RegisterName,
        sign_register_name: RegisterName,
        noise_ref: StrRef,
        num_subsystems: int,
        modifier_ref: StrRef = "",
    ):
        self.register_name = register_name
        self.sign_register_name = sign_register_name
        self._noise_ref = noise_ref
        self._modifier_ref = modifier_ref
        self._num_subsystems = num_subsystems

    def _to_json_dict(self) -> dict[str, str]:
        return {
            "node_type": 5,
            "register_name": self.register_name,
            "sign_register_name": self.sign_register_name,
            "noise_ref": self._noise_ref,
            "modifier_ref": self.modifier_ref,
            "num_subsystems": self.num_subsystems,
        }

    @property
    def outgoing_register_type(self) -> VirtualType:
        return VirtualType.PAULI

    def instantiates(self) -> dict[RegisterName, tuple[NumSubsystems, VirtualType]]:
        return {
            self.register_name: (self._num_subsystems, VirtualType.PAULI),
            self.sign_register_name: (1, VirtualType.Z2),
        }

    def sample(self, registers, size, rng, **kwargs):
        if (noise_map := kwargs.get("noise_maps", {}).get(self._noise_ref)) is None:
            raise SamplexRuntimeError(f"A noise map for '{self._noise_ref}' was not specified.")
        if (num_qubits := noise_map.num_qubits) != self._num_subsystems:
            raise SamplexRuntimeError(
                f"Received a noise map acting on `{num_qubits}` qubits for "
                f"'{self._noise_ref}' when it requires `{self._num_subsystems}`."
            )
        if self._modifier_ref:
            scale = kwargs.get("noise_scales", {}).get(self._modifier_ref, 1.0)
            local_scale = kwargs.get("local_scales", {}).get(
                self._modifier_ref, np.ones(noise_map.num_terms)
            )

            if len(local_scale) != noise_map.num_terms:
                raise SamplexRuntimeError(
                    f"Received a noise map '{self._noise_ref}' with `{noise_map.num_terms}` "
                    f"terms but a local scale from reference '{self._modifier_ref}' with "
                    f"`{len(local_scale)}` terms."
                )
            scaled_rates = noise_map.rates * scale * local_scale
            noise_map = PauliLindbladMap.from_sparse_list(
                [
                    (paulis, qubit_idxs, scaled_rate)
                    for (paulis, qubit_idxs, _), scaled_rate in zip(
                        noise_map.to_sparse_list(), scaled_rates
                    )
                ],
                noise_map.num_qubits,
            )
        signs, samples = noise_map.signed_sample(size, rng.bit_generator.random_raw())
        registers[self.register_name] = PauliRegister.from_paulis(samples)
        registers[self.sign_register_name] = Z2Register(signs.reshape(1, -1))

    def get_style(self):
        return super().get_style().append_data("Register", repr(self.register_name))
